**CreateGo DataAction JSON DSL Structure**

**DataAction JSON DSL Overview**  
CreateGo allows you to define **Data Actions** using a JSON-based DSL. This DSL declaratively describes operations like making REST API calls or querying/updating a local database. Each data action is identified by a unique **id** and specifies the action type (**dataActionType**) and how it operates. The following outlines the overall JSON structure of a data action and its key fields:

* **id** (string, required): The unique identifier for the data action. For example, "id": "restApiGetAction". At runtime, this ID is used to reference and execute the action.  
* **dataActionType** (string, required): The type of action. Currently, CreateGo supports "SQL" and "REST". The fields required in the JSON will differ based on this type (see specific sections below).  
* **method** (string, required): Specifies the specific operation the action will perform.  
  * If **dataActionType** is "SQL": This indicates the type of SQL query, e.g. "SELECT", "INSERT", "UPDATE", "DELETE", etc. (usually written in uppercase). The DSL runtime uses this to determine how to handle the query result.  
  * If **dataActionType** is "REST": This indicates the HTTP request method to use (HTTP verb), e.g. "GET", "POST", "PUT", "DELETE", etc. (case-insensitive, but conventionally uppercase).  
* **label** (string, optional): A human-readable name or label for the action. This is used for identification in the UI or documentation, describing the purpose of the action.  
* **description** (string, optional): A detailed description of the action. This can be used as a note about the action’s purpose or behavior for documentation and maintainability.  
* **saveTo** (string, optional): A target variable key where the result of the action execution will be stored. If provided, after execution the DSL runtime will save the result data into a variable/model with this key (for example, binding the result to a global state variable like \#\_appData or a temporary storage like \#\_tempData).  
* **values** (array, optional): Each data action can define a **values** array describing the parameters required for execution. **values** is a list of parameter definition objects, where each object defines one parameter:  
  * **name** (string): The parameter name. This name is used as a key in JSON and can be referenced or substituted into the query or endpoint at runtime by the DSL executor.  
  * **type** (string): The data type of the parameter. Examples include "string", "int", "double", "bool", "object", "list", etc. For instance, an **object** type might be a JSON object (e.g. for headers), and **list** represents an array of values.  
  * **required** (bool): Whether the parameter is required. If true, a value must be provided before execution or the DSL will throw an error. If false, the parameter is optional.  
  * **default** (any type, optional): A default value for the parameter, used if no value is provided at runtime. For example, you might set a default Content-Type in headers.  
  * **description** (string, optional): A description or note about this parameter. This is purely for documentation, explaining the purpose or usage of the parameter.

**Example:** An example **values** array for a data action of type "REST" might look like:  
"values": \[  
  { "name": "baseUrl",     "type": "string",  "required": true,  "description": "Base URL of the API" },  
  { "name": "endpoint",    "type": "string",  "required": true },  
  { "name": "headers",     "type": "object",  "required": false, "default": {}, "description": "HTTP headers object" },  
  { "name": "authJwt",     "type": "string",  "required": false, "description": "JWT token for Authorization" },  
  { "name": "method",      "type": "string",  "required": true },  
  { "name": "pathParams",  "type": "object",  "required": false },  
  { "name": "queryParams", "type": "object",  "required": false },  
  { "name": "body",        "type": "object",  "required": false },  
  { "name": "showLoading", "type": "bool",    "required": false, "default": false },  
  { "name": "dismissible", "type": "bool",    "required": false, "default": false },  
  { "name": "prettyLog",   "type": "bool",    "required": false, "default": false },  
  { "name": "saveTo",      "type": "string",  "required": false }  
\]  
The above example defines all the possible parameters for a REST API call action. Here, baseUrl, endpoint (or path), and method are required, while the other fields are optional.

**DataActionType "SQL" (SQLite Action)**  
When **dataActionType** is "SQL", the data action represents a query to the local **SQLite** database. In this case, the JSON DSL should include the following fields:

* **query** (string, required): The SQL query string to execute. You can use ? placeholders in the query to denote parameters that will be bound at runtime. For example:  
  "query": "SELECT \* FROM users WHERE age \> ? AND city \= ?"  
  Here, the ? marks will be replaced with actual values when the action is run.  
* **method** (string, required): The type of SQL operation. This should typically be one of **SELECT**, **INSERT**, **UPDATE**, or **DELETE** (written in uppercase). This field tells the DSL runtime how to handle the results of the query. For example, if method is SELECT, the executor knows to expect and return result rows; if INSERT or UPDATE, it might return the number of affected rows or the new record’s ID, etc.  
* **values** (array, optional): A list of parameter definitions corresponding to the ? placeholders in the query. Each entry in this array provides the details (name, type, required, etc.) for one parameter that will be bound to the SQL query.  
  * **Important – Order Matters:** The order of items in the values array is critical. The first item corresponds to the first ? in the query, the second item to the second ?, and so on. For example, if the query is WHERE age \> ? AND city \= ?, you must define two parameters in **values** and ensure the first is the age value and the second is the city value, in that exact order.  
  * **Placeholder Count Validation:** The DSL runtime will verify at execution time that the number of provided parameter values matches the number of ? placeholders in the query. If they do not match, execution is aborted and an error is returned. For instance, if the query contains 2 placeholders but only 1 value is supplied, the action will throw an error before attempting the query. This preventative check ensures there are no mismatches between query parameters and provided values.  
* **Other Common Options:** You can also use common optional fields such as **label**, **description**, **showLoading**, **dismissible**, and **saveTo** in an SQL action:  
  * **showLoading** (bool): Whether to display a loading dialog while the query is executing. If true, a loading spinner dialog is shown during the query execution and hidden upon completion. This is useful to improve UX for long-running queries. Default is false (no loading UI).  
  * **dismissible** (bool): If **showLoading** is enabled, this flag determines whether the displayed loading dialog can be manually canceled by the user. Default is false. If set to true, the user can dismiss the loading dialog before the query completes.  
  * **saveTo** (string): A key for a variable in which to save the query result. If specified, the result of the query will be stored in the application’s state model under this key. (For example, "saveTo": "\#\_tempData.queryResult" would save the result into \#\_tempData.queryResult.)

**Result Processing:** After the SQLite query executes, the DSL runtime formats the result based on the **method**:

* For **SELECT** queries: The result set is returned as a List of Maps, where each list element is a map representing a row (with column names as keys and their values). If the query finds only a single row, the system may return a single Map instead of a List for convenience (depending on implementation). If no rows are returned, an empty list \[\] is returned.  
* For **INSERT** queries: The action returns the last inserted row ID (as provided by the SQLite library) upon success.  
* For **UPDATE**/**DELETE** queries: The action returns the number of rows affected (the count of rows updated or deleted).  
* For DDL statements or other queries that don’t produce result sets (e.g. CREATE TABLE): There may not be a meaningful return value besides a success status. The DSL executor might return null or an empty value for such cases.

In all cases, if a **saveTo** variable is specified for the action, the DSL runtime will automatically store the result into that variable after execution (regardless of the result type).  
**Example:** Below is an example JSON definition for a simple SQL data action:  
{  
  "id": "selectUserById",  
  "dataActionType": "SQL",  
  "label": "Fetch Single User",  
  "query": "SELECT \* FROM users WHERE id \= ?",  
  "method": "SELECT",  
  "values": \[  
    { "name": "id", "type": "int", "required": true }  
  \]  
}  
This JSON defines a data action with id **selectUserById**. It is a "SQL" action, and because the query contains one ? placeholder, the **values** array includes the corresponding parameter definition for **id**. When this action is executed (with an actual id value provided at runtime), the SQLite query will run and return the result as a List/Map. If a **saveTo** target were specified, the result would also be saved to that location.

**SQL Method Examples**  
To illustrate different types of SQL actions, here are examples for each common SQL method:

* **SELECT Example (Data Retrieval):**  
  {  
    "id": "getOrderList",  
    "dataActionType": "SQL",  
    "label": "Retrieve Order List",  
    "method": "SELECT",  
    "query": "SELECT order\_id, status FROM orders WHERE user\_id \= ? ORDER BY order\_date DESC",  
    "values": \[  
      { "name": "userId", "type": "number", "required": true, "description": "User ID" }  
    \]  
  }  
  *This action fetches a list of orders (order\_id and status) for a given user, identified by userId. It uses a SELECT query with one parameter and returns the list of orders.*  
* **INSERT Example (Data Insertion):**  
  {  
    "id": "insertUser",  
    "dataActionType": "SQL",  
    "label": "Add New User",  
    "method": "INSERT",  
    "query": "INSERT INTO users (name, email) VALUES (?, ?)",  
    "values": \[  
      { "name": "name",  "type": "string", "required": true, "description": "User name" },  
      { "name": "email", "type": "string", "required": true, "description": "User email" }  
    \]  
  }  
  *This action inserts a new user into the users table with a name and email. It has two placeholders in the SQL, corresponding to the name and email values provided.*  
* **UPDATE Example (Data Update):**  
  {  
    "id": "updateUserEmail",  
    "dataActionType": "SQL",  
    "label": "Update User Email",  
    "method": "UPDATE",  
    "query": "UPDATE users SET email \= ? WHERE user\_id \= ?",  
    "values": \[  
      { "name": "email",  "type": "string", "required": true, "description": "New email" },  
      { "name": "userId", "type": "number", "required": true, "description": "User ID" }  
    \]  
  }  
  *This action updates a user's email in the database. It takes two parameters – the new email and the user’s ID – to execute the UPDATE statement.*  
* **DELETE Example (Data Deletion):**  
  {  
    "id": "deleteProduct",  
    "dataActionType": "SQL",  
    "label": "Delete Product",  
    "method": "DELETE",  
    "query": "DELETE FROM products WHERE product\_id \= ?",  
    "values": \[  
      { "name": "productId", "type": "number", "required": true, "description": "Product ID to delete" }  
    \]  
  }  
  *This action deletes a product from the products table by its ID. It requires one parameter (productId) to specify which product to remove.*

**DataActionType "REST" (RESTful API Action)**  
When **dataActionType** is "REST", the data action represents a call to a RESTful HTTP API. The DSL defines a remote HTTP request and its details. The main fields for a REST-type action are as follows:

* **endpoint** (string, required): The endpoint URI path for the API call. This is typically the path *after* the base URL (and can include path parameters or query string if necessary). For example: "/api/users/{userId}" or "/v1/search?keyword={query}".  
  * You can include **path parameters** in the endpoint by enclosing them in curly braces { }. For instance, an endpoint could be "/api/users/{id}/posts/{postId}". These placeholders indicate variables that will be replaced with actual values at runtime (see **pathParams** below for how to supply them).  
* **baseUrl** (string, required): The base URL of the API (protocol and domain). This is prepended to the endpoint path if the endpoint is given as a relative path. For example: "https://example.com". If the endpoint field already includes a full URL (starting with http:// or https://), then baseUrl may be omitted, but in general it’s recommended to keep them separate. If no baseUrl is provided for a relative endpoint, the DSL execution will error out (because it cannot form a complete URL).  
* **method** (string, required): The HTTP request method (verb) to use. For example "GET", "POST", "PUT", "DELETE", etc. (Not case-sensitive, but typically written in uppercase.) This determines the type of HTTP call (GET for retrieval, POST for creation, PUT for full update, DELETE for deletion, etc.).  
* **headers** (object, optional): A map of HTTP header key-value pairs to include in the request. For example:  
  "headers": {   
    "Content-Type": "application/json",   
    "x-trace-id": "12345"   
  }  
  You can specify static header values as shown above, or provide dynamic values at runtime (via the **values** array or specific fields like authJwt).  
  * **Authorization Header Shortcut:** If you provide an **authJwt** value (see below), the execution engine will automatically add the appropriate Authorization headers for you, so you often don’t need to manually put an Authorization header in this field. Specifically, if authJwt is given, an Authorization: Bearer \<token\> header (and an apikey: \<token\> header) will be added automatically. As a developer, you can simply supply the JWT through the authJwt parameter and trust that the runtime will set up the auth headers.  
* **pathParams** (object, optional): A map of values for any **path parameters** in the endpoint. Each key in this object should match a placeholder name in the endpoint path, and the value is the actual value to substitute.  
  * At runtime, the DSL executor will replace any {...} placeholders in the endpoint string with the corresponding values from **pathParams**. All substituted values are URL-encoded to ensure the resulting URL is valid. For example, if the endpoint is "/users/{id}" and pathParams is { "id": 42 }, the final request URL becomes "/users/42".  
  * **All placeholders must be provided:** Every path variable indicated by {} in the endpoint must have a corresponding entry in pathParams (or be provided as a parameter in **values** with the same name) when the action executes. If any path parameter is missing, the URL cannot be constructed and the action will throw an error.  
  * *(Note: Internally, CreateGo handles endpoint and pathParams by constructing a final path. The DSL executor treats the endpoint as the path and uses the given pathParams map to perform the substitution (via the internal CgDioClient HTTP client).)*  
* **queryParams** (object, optional): A map of query string parameters to append to the URL. Each key-value in this object will be added to the URL’s query string. For example, specifying "queryParams": { "page": 2, "keyword": "flutter" } will result in the URL ending with ?page=2\&keyword=flutter. This field is especially useful for GET requests. It improves readability and maintainability by avoiding manual string concatenation in the endpoint for query strings.  
* **body** (object or other type, optional): The body data for the HTTP request. This is typically used in POST or PUT requests to send JSON payload. For example, setting "body": { "name": "Alice", "age": 30 } will send that JSON object as the request body. Ensure that the **Content-Type** header is set appropriately (e.g. "application/json" for JSON payloads). The DSL’s HTTP client (CgDioClient) will serialize this data and include it in the request. (The body can be any type or structure required by the API, often an object for JSON.)  
* **authJwt** (string, optional): A convenience field to directly provide a JWT (JSON Web Token) or similar auth token for the request. If this is set, as mentioned, the runtime will automatically configure the Authorization headers (e.g., Authorization: Bearer \<token\> and apikey: \<token\>). Typically, you would obtain a token after login and store it, then supply it to this field when executing the DSL action, instead of manually constructing headers each time.  
* **showLoading** (bool, optional): Controls whether a loading UI is shown during the API call. If true, a loading dialog or spinner is displayed when the request starts and is dismissed when a response is received. By design, the default for REST actions is true (so if you omit this field, loading will be shown by default). You can disable it on a per-action basis by setting this to false if desired.  
* **dismissible** (bool, optional): If a loading dialog is shown (showLoading is true), this flag determines whether the user can cancel/dismiss the loading dialog while the request is in progress. Default is false. (This value is used to configure the loading UI behavior.)  
* **prettyLog** (bool, optional): A debug option that controls formatted logging of the request and response. If true, the request/response data (e.g., JSON payloads) will be logged in a pretty-printed, indented format, making them easier to read. This is typically enabled by default in development mode (e.g., when running in kDebugMode in Flutter).  
* **saveTo** (string, optional): A key for a variable in which to store the API response data. If set, the DSL executor will save the response data into the application state under this key. (For example, "saveTo": "appData.userList" would place the decoded response into the global state object appData.userList.)

**Path Parameter Replacement Rules:** In a REST action, any path variables in the endpoint specified with {} will be replaced using the provided **pathParams** map. This substitution is handled internally by the DSL engine automatically, and values are inserted in a URL-safe (URL-encoded) manner. For example, given an endpoint "/items/{itemId}/detail" and pathParams: { "itemId": "ABC 123" }, the runtime will encode the space and construct the final URL as "/items/ABC%20123/detail".  
If you do not explicitly use pathParams but have defined a parameter in **values** with the same name as a path placeholder, the runtime may also use that value to perform the substitution. However, the typical pattern is to explicitly use the pathParams map for clarity. In practice, this means when defining the DSL, you either include a single object parameter that corresponds to pathParams, or you supply the pathParams at runtime (for example, from a parent flow that calls this action). Relying on an explicit pathParams field makes the intent clearer and the substitution more straightforward.  
**Request Header Composition:** All headers specified in the **headers** field are included in the request as given. In addition, if an **authJwt** value is provided, the runtime automatically adds the following two headers to the request:

* **Authorization: Bearer** *\<token\>*  
* **apikey:** *\<token\>*

This behavior is part of CreateGo’s convention to standardize token-based authentication; it allows you to simply provide a JWT token and have the proper authentication headers attached without additional coding. You can still add any other custom headers via the **headers** object as needed. (If the same header key is specified both in headers and via the automatic authJwt insertion, the duplicate key will be resolved by using the last set value. For example, if an Authorization header is given in both headers and via authJwt, the implementation will apply authJwt last, effectively overriding the manual header.)

**REST API Method Examples**  
To demonstrate different RESTful actions, here are examples for common HTTP methods:

* **GET Example (Data Retrieval):**  
  {  
    "id": "getUserPosts",  
    "dataActionType": "REST",  
    "label": "Retrieve User Posts",  
    "endpoint": "/api/users/{userId}/posts",  
    "method": "GET",  
    "headers": {  
      "Authorization": "Bearer {authJwt}",  
      "Content-Type": "application/json"  
    },  
    "values": \[  
      { "name": "userId", "type": "string", "required": true, "description": "ID of the user to retrieve posts for" },  
      { "name": "authJwt", "type": "string", "required": true, "description": "JWT authentication token" }  
    \]  
  }  
  *This action retrieves a list of posts for a given user. It uses a GET request to an endpoint with a path parameter for userId. An auth token must be provided; the token is used in the Authorization header.*  
* **POST Example (Data Creation):**  
  {  
    "id": "createOrder",  
    "dataActionType": "REST",  
    "label": "Create New Order",  
    "endpoint": "/api/orders",  
    "method": "POST",  
    "headers": {  
      "Authorization": "Bearer {authJwt}",  
      "Content-Type": "application/json"  
    },  
    "values": \[  
      { "name": "userId", "type": "number", "required": true, "description": "Orderer ID" },  
      { "name": "items",  "type": "array\<object\>", "required": true, "description": "List of order items" },  
      { "name": "authJwt", "type": "string", "required": true, "description": "JWT authentication token" }  
    \]  
  }  
  *This action creates a new order via a POST request. The body (not explicitly shown in the DSL snippet) would be constructed from the provided values (e.g., userId and items list). The items parameter here is expected to be an array of objects, representing the products in the order.*  
* **PUT Example (Full Update):**  
  {  
    "id": "updateOrder",  
    "dataActionType": "REST",  
    "label": "Update Order Status",  
    "endpoint": "/api/orders/{orderId}",  
    "method": "PUT",  
    "headers": {  
      "Authorization": "Bearer {authJwt}",  
      "Content-Type": "application/json"  
    },  
    "values": \[  
      { "name": "orderId", "type": "number", "required": true, "description": "Order ID" },  
      { "name": "status",  "type": "string", "required": true, "description": "Order status to update" },  
      { "name": "authJwt", "type": "string", "required": true, "description": "JWT authentication token" }  
    \]  
  }  
  *This action updates an entire order (in this case, likely just the status field) via a PUT request. It targets a specific order by orderId and requires a new status value.*  
* **PATCH Example (Partial Update):**  
  {  
    "id": "modifyUserEmail",  
    "dataActionType": "REST",  
    "label": "Modify User Email",  
    "endpoint": "/api/users/{userId}",  
    "method": "PATCH",  
    "headers": {  
      "Authorization": "Bearer {authJwt}",  
      "Content-Type": "application/json"  
    },  
    "values": \[  
      { "name": "userId", "type": "number", "required": true, "description": "User ID" },  
      { "name": "email",  "type": "string", "required": true, "description": "New email address" },  
      { "name": "authJwt", "type": "string", "required": true, "description": "JWT authentication token" }  
    \]  
  }  
  *This action modifies a user's email with a PATCH request. It only changes the email field for the specified userId, illustrating a partial update.*  
* **DELETE Example (Data Deletion):**  
  {  
    "id": "deleteProduct",  
    "dataActionType": "REST",  
    "label": "Delete Product",  
    "endpoint": "/api/products/{productId}",  
    "method": "DELETE",  
    "headers": {  
      "Authorization": "Bearer {authJwt}"  
      /\* Content-Type may not be needed for a DELETE; if no body is sent \*/  
    },  
    "values": \[  
      { "name": "productId", "type": "number", "required": true, "description": "Product ID to delete" },  
      { "name": "authJwt",  "type": "string", "required": true, "description": "JWT authentication token" }  
    \]  
  }  
  *This action deletes a product via a DELETE request. It requires the productId of the item to delete. Only the Authorization header is needed in this case (assuming no request body is used in the DELETE call).*

**validateValuesWithSpec Function – DSL Input Validation and Caching**  
The CreateGo runtime includes a utility function called **validateValuesWithSpec**. This function validates the input parameters for an action against the action’s DSL specification before execution. By running this validation for each action invocation, the system can catch missing or incorrect parameters (and type mismatches) early, improving robustness. The key behaviors of this function are:

* **Spec vs. Input Comparison:** It retrieves the expected parameters specification from the action’s DSL (typically from the action’s JSON definition under the values array, where each entry has a name, type, required flag, etc.). For example, the spec might include an entry like {"name": "userId", "type": "int", "required": true}. The function iterates over this spec list and checks the actual provided values map to ensure that for each expected parameter name, a value is present, and that its type matches the specified type.  
* **Required Field Check:** If any spec entry is marked required: true but the provided values do not contain that key (or the value is null), the validation fails. In such cases, the function will generate an error indicating a missing required parameter.  
* **Type Verification and Conversion:** The function verifies the type of each provided value against the expected **type** from the spec. For example, if the spec expects an "int" but the provided value is a string, the function may attempt to convert the string to a number (if possible) or treat it as a type error. The validation assumes common type strings like "string", "int", "double", "bool", etc., and checks accordingly (in Dart, for instance, using is int, is String, etc.). If needed, the function might allow some flexibility (for example, treating both int and double as valid for a spec type of "num", or parsing a numeric string into an int via int.parse). If conversion is not possible or the type is mismatched, it will flag an error.  
* **Handling Extra Values:** If the provided values contain keys that are **not defined** in the spec, it typically does not cause a failure. Those extra inputs are essentially ignored by the DSL execution (since they wouldn't be used in the query or request). A stricter implementation might log a warning or drop those undefined inputs, but it’s usually safe to have them since they have no effect if not referenced by the DSL.  
* **Caching (DSL Hash-Based):** To avoid repeating the same validation logic for identical action specs, the system can cache the parsed spec structure. The spec list content can be identified by a hash or unique key. For example, the JSON representation of the spec list (obtained via something like jsonEncode(specList)) could be hashed (e.g., MD5) and used as a cache key, or the spec’s string itself could serve as a key.  
  * If a spec has not been seen before, validateValuesWithSpec will parse the spec list (possibly into an internal representation, like a list of ValueSpec objects) and store it in the cache.  
  * If the same spec is encountered again, the function can reuse the previously cached spec info instead of parsing it from scratch.  
  * By caching, if the same action (with the same DSL spec) executes multiple times, the cost of parsing and setting up the spec validation is reduced. Using a consistent hash or key also helps with memory reuse and management of cached specs.  
* **Return Value:** If validation succeeds, the function can either return a success indicator (e.g., true or a Right value if using an Either type for error handling) or simply complete without issues. If there is a validation error, the function will return an error result – for example, a Left value containing a message about which field is problematic, or it might throw an exception that includes details of the failure. In CreateGo’s implementation, for instance, validateValuesWithSpec might not directly return an Either; instead it could throw an error or return a boolean, and the action execution code catches that and wraps it into an Either Left/Right result. In any case, on failure the error will include information about the reason (such as a missing required parameter or a type mismatch), allowing the developer to diagnose the issue.

Overall, the validateValuesWithSpec utility ensures that each DataAction receives the correct inputs before the action proceeds, thus preventing runtime errors or unexpected behavior due to invalid parameters. By leveraging caching and early checks, it contributes to both performance and reliability of the CreateGo platform’s action execution.

**CreateGo DataAction System**

**database\_manager.dart**  
import 'package:sqlite3/sqlite3.dart';

/// A central manager for SQLite database connections identified by a \`dbKey\`.  
/// This allows multiple databases to be opened and referenced by key.  
class DatabaseManager {  
  // Internal map storing open database connections by their key.  
  static final Map\<String, Database\> \_databases \= {};

  /// Retrieve an open database by its key. Returns null if no such database is open.  
  static Database? getDatabase(String key) \=\> \_databases\[key\];

  /// Register (store) an open database with a given key.  
  static void registerDatabase(String key, Database db) {  
    \_databases\[key\] \= db;  
  }

  /// Remove (unregister) a database by key and return it. Returns null if not found.  
  static Database? unregisterDatabase(String key) {  
    return \_databases.remove(key);  
  }  
}  
*The DatabaseManager maintains a static map of open SQLite Database instances keyed by a string. The getDatabase method is used by data actions (e.g. SqliteDataAction) to fetch an open connection for executing queries. The registerDatabase and unregisterDatabase methods are used by the open/close actions to add or remove connections. This central manager enables multiple databases to be opened (for example, separate databases for different features or user accounts) and referenced by a dbKey.*

**validate\_values\_with\_spec.dart**  
import 'dart:convert';  
import 'package:fpdart/fpdart.dart';

/// Internal function to count the number of '?' placeholders in an SQL query.  
int \_countPlaceholders(String sql) {  
  return RegExp(r'\\?').allMatches(sql).length;  
}

/// Cache for DSL validation to avoid repeated processing for the same definition.  
final Map\<String, Map\<String, dynamic\>\> \_validationCache \= {};

/// Validates and merges \`paramsValues\` against the DSL spec in \`dataActionJson\`.  
/// Ensures required parameters are provided, types match, and default values are applied.  
/// Caches the spec analysis by a hash of the DSL JSON for performance.  
Either\<String, Map\<String, dynamic\>\> validateValuesWithSpec(  
  Map\<String, dynamic\> dataActionJson,  
  Map\<String, dynamic\> paramsValues,  
) {  
  // Compute a hash key for the dataAction JSON to use for caching.  
  String cacheKey;  
  try {  
    // Use JSON string hashCode as a simple hash for the DSL definition.  
    cacheKey \= jsonEncode(dataActionJson).hashCode.toString();  
  } catch (\_) {  
    // Fallback: use dataAction id if available.  
    cacheKey \= dataActionJson\['id'\]?.toString() ?? 'unknown';  
  }

  // Retrieve or parse the spec (list of parameter definitions).  
  List\<dynamic\> specList;  
  int? placeholderCount;  
  if (\_validationCache.containsKey(cacheKey)) {  
    // Use cached spec if available.  
    specList \= \_validationCache\[cacheKey\]\!\['specList'\] as List\<dynamic\>;  
    placeholderCount \= \_validationCache\[cacheKey\]\!\['placeholderCount'\] as int?;  
  } else {  
    // Parse spec from DSL JSON.  
    specList \= (dataActionJson\['values'\] as List\<dynamic\>? ?? \<dynamic\>\[\]);  
    // If this is an SQL action, perform static validation of query vs parameters.  
    if (dataActionJson\['dataActionType'\] \== 'SQL') {  
      final String query \= (dataActionJson\['query'\] ?? '') as String;  
      final String method \= (dataActionJson\['method'\] ?? '') as String;  
      if (query.isEmpty || method.isEmpty) {  
        return left("DataAction spec error: 'query' and 'method' must be provided for SQL actions.");  
      }  
      placeholderCount \= \_countPlaceholders(query);  
      if (placeholderCount \!= specList.length) {  
        return left("DataAction spec error: query expects $placeholderCount values, "  
                   "but ${specList.length} parameter definitions provided.");  
      }  
    }  
    // Cache the spec and placeholder count for future validations.  
    \_validationCache\[cacheKey\] \= {  
      'specList': specList,  
      'placeholderCount': placeholderCount  
    };  
  }

  // Prepare the result map of validated values.  
  final Map\<String, dynamic\> resultValues \= {};

  // Check if the caller provided a raw list of values (for SQL positional parameters).  
  if (paramsValues.containsKey('values') && paramsValues\['values'\] is List) {  
    List\<dynamic\> providedList \= paramsValues\['values'\];  
    // If a placeholder count is known (SQL), validate the list length against it.  
    if (placeholderCount \!= null && providedList.length \!= placeholderCount) {  
      return left("Error: expected $placeholderCount values, but got ${providedList.length}.");  
    }  
    // If no placeholder count (e.g. REST action), ensure the list length matches spec list length.  
    if (placeholderCount \== null && providedList.length \!= specList.length) {  
      return left("Error: expected ${specList.length} values, but got ${providedList.length}.");  
    }  
    // Map each provided value to its parameter name based on spec order.  
    for (int i \= 0; i \< specList.length; i++) {  
      if (specList\[i\] is Map\<String, dynamic\>) {  
        final paramName \= specList\[i\]\['name'\];  
        dynamic value \= (i \< providedList.length) ? providedList\[i\] : null;  
        resultValues\[paramName\] \= value;  
      }  
    }  
  }

  // Iterate through each parameter definition in the spec for validation.  
  for (var paramDef in specList) {  
    if (paramDef is\! Map\<String, dynamic\>) continue;  
    final String name \= paramDef\['name'\];  
    final String type \= (paramDef\['type'\] ?? 'string').toString().toLowerCase();  
    final bool required \= paramDef\['required'\] \== true;  
    // The default value from spec (if any).  
    final dynamic defaultVal \= paramDef.containsKey('default') ? paramDef\['default'\] : null;

    // Determine the provided value for this parameter.  
    dynamic value;  
    if (resultValues.containsKey(name)) {  
      // Value already set from list handling.  
      value \= resultValues\[name\];  
    } else if (paramsValues.containsKey(name)) {  
      value \= paramsValues\[name\];  
    } else {  
      value \= null;  
    }

    // If value is not provided, use default if available.  
    if (value \== null || (value is String && value.isEmpty)) {  
      if (value \== null && defaultVal \!= null) {  
        value \= defaultVal;  
      }  
    }

    // Check required constraint.  
    if (required && (value \== null || (value is String && value.isEmpty))) {  
      return left("Error: Missing required parameter '$name'.");  
    }

    // Type checking: skip if value is null (allowed for optional parameters).  
    if (value \!= null) {  
      bool typeOk \= true;  
      switch (type) {  
        case 'string':  
          typeOk \= value is String;  
          break;  
        case 'int':  
          typeOk \= value is int;  
          break;  
        case 'double':  
          typeOk \= value is double;  
          break;  
        case 'number':  
          // "number" type can be int or double.  
          typeOk \= value is num;   
          break;  
        case 'bool':  
          typeOk \= value is bool;  
          break;  
        case 'object':  
          typeOk \= value is Map;  
          break;  
        case 'list':  
          typeOk \= value is List;  
          break;  
        default:  
          // Unknown types can be considered valid for any value, or we treat as error.  
          typeOk \= true;  
          break;  
      }  
      if (\!typeOk) {  
        return left("Error: Parameter '$name' should be of type $type.");  
      }  
    }

    // Save the validated (or defaulted) value in result map.  
    resultValues\[name\] \= value;  
  }

  // If this is an SQL action, ensure the final number of values matches the query placeholders.  
  if (dataActionJson\['dataActionType'\] \== 'SQL' && placeholderCount \!= null) {  
    // Build a list of values for placeholders from the result map.  
    int count \= 0;  
    for (var def in specList) {  
      if (def is Map\<String, dynamic\> && def.containsKey('name')) {  
        count++;  
      }  
    }  
    if (count \!= placeholderCount) {  
      // This situation should not occur if we've enforced required/defaults correctly.  
      return left("Error: Parameter count mismatch for SQL query (expected $placeholderCount, got $count).");  
    }  
  }

  return right(resultValues);  
}  
*The validateValuesWithSpec function takes a DSL definition (as a JSON map) and a map of input values, and returns an Either containing either an error message or a map of validated parameters. It first uses a cache (keyed by a hash of the DSL JSON) to store the parsed parameter spec and (for SQL actions) the count of SQL placeholders. This avoids re-parsing the same DSL repeatedly.*  
*For each parameter defined in the DSL (dataActionJson\['values'\] list), the function checks if a value was provided. It merges any default values from the spec for missing optional parameters. Required parameters that are missing (or explicitly null/empty) cause an error. It also verifies type constraints: for example, an int parameter must receive a Dart int, a bool must receive a bool, etc. The special "number" type is treated as allowing either int or double. If a list of values is provided under the key 'values' (useful for SQL actions with positional parameters), it maps those to the spec definitions in order.*  
*For SQL-type actions, the function also ensures that the number of provided values matches the number of ? placeholders in the SQL query. If everything is valid, it returns a Right containing a map of parameter names to final values (with defaults applied). If any validation fails, it returns a Left with an error message.*

**sqlite\_data\_action.dart**  
import 'dart:convert';  
import 'package:fpdart/fpdart.dart';  
import 'package:sqlite3/sqlite3.dart';  
import 'package:creatego\_packages/creatego\_packages.dart';  // For ActBase, ApiResponse, SetModelAction, etc.  
import 'package:flutter/foundation.dart';  
import 'database\_manager.dart';  
import 'validate\_values\_with\_spec.dart';

class SqliteDataAction implements ActBase {  
  final String? query;  
  final String? method;  
  final List\<dynamic\>? values;  
  final String? dbKey;       // Optional default database key for this action  
  final bool showLoading;  
  final bool dismissible;  
  final String? saveTo;

  SqliteDataAction({  
    required this.query,  
    this.method,  
    this.values,  
    this.dbKey,  
    this.showLoading \= false,  
    this.dismissible \= false,  
    this.saveTo,  
  });

  @override  
  Future\<Either\<String, ApiResponse\>\> execute(  
      BuildContext? context, String methodName, Map\<String, dynamic\> params) async {  
    // If a full DSL spec is provided in params, use it for validation and defaults.  
    Map\<String, dynamic\>? actionSpec \= params\['dataActionJSON'\] as Map\<String, dynamic\>?;  
    // Resolve the SQL query and method.  
    String resolvedQuery;  
    String resolvedMethod;  
    if (actionSpec \!= null) {  
      // Use DSL spec for base query and method.  
      resolvedQuery \= (params\['query'\] ?? actionSpec\['query'\] ?? '') as String;  
      resolvedMethod \= (params\['method'\] ?? actionSpec\['method'\] ?? '') as String;  
    } else {  
      // Fallback to the values provided in this instance (constructed defaults).  
      resolvedQuery \= (params\['query'\] ?? query ?? '') as String;  
      resolvedMethod \= (params\['method'\] ?? method ?? '') as String;  
    }  
    resolvedMethod \= resolvedMethod.toUpperCase();

    // Basic checks for required fields.  
    if (resolvedQuery.isEmpty) {  
      return left("SqliteDataAction Error: query is required.");  
    }  
    if (resolvedMethod.isEmpty) {  
      return left("SqliteDataAction Error: method is required.");  
    }

    // If DSL spec is available, validate and merge parameters using it.  
    Map\<String, dynamic\> finalParams;  
    if (actionSpec \!= null) {  
      final validation \= validateValuesWithSpec(actionSpec, params);  
      if (validation.isLeft()) {  
        // Return validation error if parameters are invalid.  
        return left(validation.swap().getOrElse(() \=\> "Parameter validation failed."));  
      }  
      finalParams \= validation.getOrElse(() \=\> {});  
    } else {  
      // No spec provided: merge this object's defaults with runtime params manually.  
      finalParams \= {};  
      // Use any provided values list or default list.  
      List\<dynamic\> valsList \= (params\['values'\] ?? values) ?? \<dynamic\>\[\];  
      for (int i \= 0; i \< valsList.length; i++) {  
        finalParams\[i.toString()\] \= valsList\[i\]; // (not using named keys since no spec)  
      }  
      // Note: Without spec, we cannot validate types or names; we assume correct usage.  
    }

    // Count placeholders and verify values count.  
    int placeholderCount \= \_countPlaceholders(resolvedQuery);  
    List\<dynamic\> resolvedValuesList;  
    if (params.containsKey('values') && params\['values'\] is List) {  
      // Use the provided list of values directly.  
      resolvedValuesList \= List\<dynamic\>.from(params\['values'\]);  
    } else if (actionSpec \!= null) {  
      // Build ordered values list from finalParams based on spec definitions.  
      resolvedValuesList \= \[\];  
      final specList \= actionSpec\['values'\] as List\<dynamic\>? ?? \<dynamic\>\[\];  
      for (var def in specList) {  
        if (def is Map\<String, dynamic\>) {  
          String name \= def\['name'\];  
          resolvedValuesList.add(finalParams\[name\]);  
        }  
      }  
    } else {  
      // No spec and no explicit list: assume values were merged in finalParams by index.  
      resolvedValuesList \= values ?? \<dynamic\>\[\];  
      if (params.isNotEmpty) {  
        // If params provided individual values (not in a list), we cannot map them without spec.  
        // We'll just fall back to using any 'values' list we have (if any).  
        resolvedValuesList \= (values ?? \<dynamic\>\[\]);  
      }  
    }  
    if (resolvedValuesList.length \!= placeholderCount) {  
      return left("SqliteDataAction Error: expected $placeholderCount values, got ${resolvedValuesList.length}.");  
    }

    try {  
      // Show a loading indicator if requested.  
      if (showLoading && context \!= null) {  
        ShowLoadingDialogActionImpl().call(context, true, dismissible);  
      }

      // Get the database connection via dbKey.  
      String dbKeyToUse \= params\['dbKey'\] ??  
          finalParams\['dbKey'\] ??  
          dbKey ??   
          'defaultDb';  
      final Database? db \= DatabaseManager.getDatabase(dbKeyToUse);  
      if (db \== null) {  
        return left("SqliteDataAction Error: No open database for key '$dbKeyToUse'.");  
      }

      // Execute the SQL query based on the method.  
      dynamic result;  
      switch (resolvedMethod) {  
        case 'SELECT':  
          // Execute query and fetch results.  
          final ResultSet resultSet \= db.select(resolvedQuery, resolvedValuesList);  
          List\<Map\<String, dynamic\>\> rows \= \[\];  
          for (final Row row in resultSet) {  
            // Convert each Row into a Map\<String, dynamic\>.  
            final Map\<String, dynamic\> rowMap \= {};  
            for (final String col in resultSet.columnNames) {  
              rowMap\[col\] \= row\[col\];  
            }  
            rows.add(rowMap);  
          }  
          if (rows.length \== 1\) {  
            result \= rows.first;  // Return a single map if exactly one row.  
          } else {  
            result \= rows;        // Return a list of maps for 0 or multiple rows.  
          }  
          break;  
        case 'INSERT':  
          // Execute insert and get the last inserted row ID.  
          db.execute(resolvedQuery, resolvedValuesList);  
          result \= db.lastInsertRowId;  
          break;  
        case 'UPDATE':  
        case 'DELETE':  
          // Execute update/delete and get the count of affected rows.  
          db.execute(resolvedQuery, resolvedValuesList);  
          result \= db.updatedRows;  
          break;  
        default:  
          // Execute any other SQL (e.g., CREATE TABLE). No specific result.  
          db.execute(resolvedQuery, resolvedValuesList);  
          result \= null;  
          break;  
      }

      // Hide the loading indicator after operation.  
      if (showLoading && context \!= null) {  
        ShowLoadingDialogActionImpl().call(context, false);  
      }

      // Save result to state if a save target is specified.  
      final String? resolvedSaveTo \=  
          params\['saveTo'\] ?? actionSpec?\['saveTo'\] ?? saveTo;  
      if (resolvedSaveTo \!= null) {  
        // Update global state or model with the result.  
        SetModelAction.set(resolvedSaveTo, result);  
      }

      // Return the result wrapped in an ApiResponse.  
      return right(ApiResponse(response: result));  
    } catch (e, stack) {  
      debugPrint('SqliteDataAction Exception: $e\\n$stack');  
      // Hide loading if it was shown, in case of error.  
      if (showLoading && context \!= null) {  
        ShowLoadingDialogActionImpl().call(context, false);  
      }  
      return left("SqliteDataAction Error: ${e.toString()}");  
    }  
  }

  /// (Optional) Convert this action to JSON for serialization.  
  Map\<String, dynamic\> toJson() {  
    return {  
      'actionId': type,  
      'params': {  
        'query': query,  
        'method': method,  
        'values': values,  
        'dbKey': dbKey,  
        'showLoading': showLoading,  
        'dismissible': dismissible,  
        'saveTo': saveTo,  
      },  
    };  
  }

  /// (Optional) Factory to create an action from a JSON map.  
  factory SqliteDataAction.fromJson(Map\<String, dynamic\> json) {  
    final params \= json\['params'\] ?? {};  
    return SqliteDataAction(  
      query: params\['query'\],  
      method: params\['method'\],  
      values: params\['values'\],  
      dbKey: params\['dbKey'\],  
      showLoading: params\['showLoading'\] ?? false,  
      dismissible: params\['dismissible'\] ?? false,  
      saveTo: params\['saveTo'\],  
    );  
  }

  String get type \=\> 'sqliteAction';  // Unique identifier for registration.

  /// Convenience method to execute this action via the Action manager.  
  void call({BuildContext? context, Map\<String, dynamic\>? params}) {  
    final mergedParams \= {  
      'query': params?\['query'\] ?? query,  
      'method': params?\['method'\] ?? method,  
      'values': params?\['values'\] ?? values,  
      'dbKey': params?\['dbKey'\] ?? dbKey,  
      'showLoading': params?\['showLoading'\] ?? showLoading,  
      'dismissible': params?\['dismissible'\] ?? dismissible,  
      'saveTo': params?\['saveTo'\] ?? saveTo,  
    };  
    debugPrint("Calling SqliteDataAction with params: $mergedParams");  
    ActionManager.instance.executeAction(context, type, mergedParams);  
  }  
}  
*The SqliteDataAction class implements ActBase to execute JSON-defined SQL actions. It handles executing parameterized SQL queries on an SQLite database. Key points:*  
*\- **Parameter resolution and validation:** If the params passed into execute() contains a dataActionJSON spec (the full DSL definition), the code uses validateValuesWithSpec to verify the incoming parameters and apply default values. This ensures that required parameters (as defined in the DSL) are present and of the correct type. If no spec is provided (for backward compatibility when the action is constructed with defaults), it falls back to using the object's own query, method, and values fields without extensive type checking.*  
*\- **Database selection:** The action expects a dbKey to identify which database connection to use. This can be provided in the DSL (as a default) or at runtime via params. If no key is given, it defaults to "defaultDb". The DatabaseManager is then used to fetch the open Database instance. If the database is not found (not opened), it returns an error.*  
*\- **SQL execution:** Depending on the SQL method (SELECT, INSERT, UPDATE, DELETE, etc.), it executes the query using the sqlite3 library. For SELECT, it collects the results into a list of maps (each map representing a row, with column names as keys). If exactly one row is returned, it simplifies the result to a single map. For INSERT, it retrieves the last inserted row ID via db.lastInsertRowId. For UPDATE/DELETE, it uses db.updatedRows to get the count of affected rows. Other SQL commands (e.g., DDL statements like CREATE TABLE) are executed without returning a result (result will be null). All database operations are wrapped in a try-catch to catch any exceptions (such as SQL syntax errors or constraint violations) and return them as a Left error.*  
*\- **Loading indicator:** If showLoading is true and a UI context is provided, the action shows a loading dialog via ShowLoadingDialogActionImpl before starting the query and hides it afterwards. This provides feedback to the user interface during potentially long-running database operations. The dismissible flag controls whether the loading dialog can be dismissed by the user.*  
*\- **Result handling:** After a successful query, if the DSL or params specified a saveTo key, the result is saved to the global state via SetModelAction.set(...). This allows the output of the data action (e.g., query result or inserted ID) to be stored in a variable for later use (for example, updating the app state or passing data to subsequent actions). Finally, the action returns a Right(ApiResponse) containing the result data.*

**restful\_data\_action.dart**  
import 'dart:convert';  
import 'package:fpdart/fpdart.dart';  
import 'package:creatego\_interface/src/dependency/dio\_client.dart';  // Provides CgDioClient and RequestMethod  
import 'package:creatego\_packages/creatego\_packages.dart';          // For ActBase, ApiResponse, SetModelAction, etc.  
import 'package:flutter/foundation.dart';  
import 'validate\_values\_with\_spec.dart';

class RestfulDataAction implements ActBase {  
  final String? baseUrl;  
  final String? path;  
  final String? method;  
  final Map\<String, String\>? headers;  
  final String? authJwt;  
  final Map\<String, dynamic\>? pathParams;  
  final Map\<String, dynamic\>? queryParams;  
  final dynamic body;  
  final bool showLoading;  
  final bool dismissible;  
  final bool prettyLog;  
  final String? saveTo;

  RestfulDataAction({  
    this.baseUrl,  
    this.path,  
    this.method,  
    this.headers,  
    this.authJwt,  
    this.pathParams,  
    this.queryParams,  
    this.body,  
    this.showLoading \= true,  
    this.dismissible \= false,  
    this.prettyLog \= kDebugMode,  
    this.saveTo,  
  });

  @override  
  Future\<Either\<String, ApiResponse\>\> execute(  
      BuildContext? context, String methodName, Map\<String, dynamic\> params) async {  
    // If a DSL spec is provided, validate and merge parameters.  
    Map\<String, dynamic\>? actionSpec \= params\['dataActionJSON'\] as Map\<String, dynamic\>?;  
    Map\<String, dynamic\> finalParams;  
    if (actionSpec \!= null) {  
      final validation \= validateValuesWithSpec(actionSpec, params);  
      if (validation.isLeft()) {  
        return left(validation.swap().getOrElse(() \=\> "Parameter validation failed."));  
      }  
      finalParams \= validation.getOrElse(() \=\> {});  
    } else {  
      // No spec: merge this instance's defaults with provided params manually.  
      finalParams \= {  
        'baseUrl': params\['baseUrl'\] ?? baseUrl,  
        'path': params\['path'\] ?? path,  
        'method': params\['method'\] ?? method,  
        'headers': params\['headers'\] ?? headers,  
        'authJwt': params\['authJwt'\] ?? authJwt,  
        'pathParams': params\['pathParams'\] ?? pathParams,  
        'queryParams': params\['queryParams'\] ?? queryParams,  
        'body': params\['body'\] ?? body,  
        'prettyLog': params\['prettyLog'\] ?? prettyLog,  
      };  
    }

    // Resolve required fields.  
    final String? resolvedBaseUrl \= finalParams\['baseUrl'\];  
    if (resolvedBaseUrl \== null || resolvedBaseUrl.isEmpty) {  
      return left("RestfulDataAction Error: baseUrl is required.");  
    }  
    // Determine HTTP method: use provided or default (if not specified, default to POST if body is present, otherwise GET).  
    String resolvedMethod \= (finalParams\['method'\] ?? '') as String;  
    if (resolvedMethod.isEmpty) {  
      resolvedMethod \= (finalParams\['body'\] \!= null) ? 'POST' : 'GET';  
    }  
    resolvedMethod \= resolvedMethod.toUpperCase();

    // Prepare headers and authentication.  
    Map\<String, String\>? resolvedHeaders;  
    if (finalParams\['headers'\] \!= null) {  
      // Cast any headers to the proper Map\<String, String\>.  
      resolvedHeaders \= Map\<String, String\>.from(finalParams\['headers'\]);  
    }  
    String? resolvedAuthJwt \= finalParams\['authJwt'\] as String?;  
    if (resolvedAuthJwt \!= null && resolvedAuthJwt.isNotEmpty) {  
      resolvedHeaders ??= \<String, String\>{};  
      resolvedHeaders\['Authorization'\] \= 'Bearer $resolvedAuthJwt';  
      // Optionally include API key header if required by backend convention.  
      resolvedHeaders\['apikey'\] \= resolvedAuthJwt;  
    }

    try {  
      // Show loading indicator if required.  
      if (showLoading && context \!= null) {  
        ShowLoadingDialogActionImpl().call(context, true, dismissible);  
      }

      // Create the HTTP client and configure the request.  
      final client \= CgDioClient(  
        baseUrl: resolvedBaseUrl,  
        path: (finalParams\['path'\] ?? '/') as String,  
        headers: resolvedHeaders,  
        method: RequestMethod.values.byName(resolvedMethod.toLowerCase()),  
        pathParams: finalParams\['pathParams'\] as Map\<String, dynamic\>?,  
        queryParams: finalParams\['queryParams'\] as Map\<String, dynamic\>?,  
        body: finalParams\['body'\],  
        prettyLog: finalParams\['prettyLog'\] ?? kDebugMode,  
      );

      debugPrint("\>\>\> RestfulDataAction: calling $resolvedMethod $resolvedBaseUrl${finalParams\['path'\] ?? '/'}");  
      final Either\<String, dynamic\> rsp \= await client.request();

      // Hide loading indicator after the request completes.  
      if (showLoading && context \!= null) {  
        ShowLoadingDialogActionImpl().call(context, false);  
      }

      if (rsp.isLeft()) {  
        debugPrint("\>\>\> RestfulDataAction: API request failed");  
        // Extract error message from Left and return.  
        return left(rsp.getLeft().toNullable() ?? "REST API request error");  
      }

      debugPrint("\>\>\> RestfulDataAction: API request succeeded");  
      // Get the response body/data.  
      final dynamic responseData \= rsp.getOrElse((\_) \=\> null);  
      // Save to state if required.  
      final String? resolvedSaveTo \= params\['saveTo'\] ?? actionSpec?\['saveTo'\] ?? saveTo;  
      if (resolvedSaveTo \!= null) {  
        SetModelAction.set(resolvedSaveTo, responseData);  
      }  
      // Wrap in ApiResponse and return.  
      return right(ApiResponse(response: responseData));  
    } catch (e, stack) {  
      debugPrint("RestfulDataAction Exception: $e\\n$stack");  
      if (showLoading && context \!= null) {  
        ShowLoadingDialogActionImpl().call(context, false);  
      }  
      return left("RestfulDataAction Error: ${e.toString()}");  
    }  
  }

  /// (Optional) Convert to JSON for serialization.  
  Map\<String, dynamic\> toJson() {  
    return {  
      'actionId': type,  
      'params': {  
        'baseUrl': baseUrl,  
        'path': path,  
        'method': method,  
        'headers': headers,  
        'authJwt': authJwt,  
        'pathParams': pathParams,  
        'queryParams': queryParams,  
        'body': body,  
        'showLoading': showLoading,  
        'dismissible': dismissible,  
        'prettyLog': prettyLog,  
        'saveTo': saveTo,  
      },  
    };  
  }

  factory RestfulDataAction.fromJson(Map\<String, dynamic\> json) {  
    final params \= json\['params'\] ?? {};  
    return RestfulDataAction(  
      baseUrl: params\['baseUrl'\],  
      path: params\['path'\],  
      method: params\['method'\],  
      headers: params\['headers'\] \!= null ? Map\<String, String\>.from(params\['headers'\]) : null,  
      authJwt: params\['authJwt'\],  
      pathParams: params\['pathParams'\],  
      queryParams: params\['queryParams'\],  
      body: params\['body'\],  
      showLoading: params\['showLoading'\] ?? true,  
      dismissible: params\['dismissible'\] ?? false,  
      prettyLog: params\['prettyLog'\] ?? kDebugMode,  
      saveTo: params\['saveTo'\],  
    );  
  }

  String get type \=\> 'restApiAction';  // Unique identifier for registration.

  void call({BuildContext? context, Map\<String, dynamic\>? params}) {  
    final merged \= {  
      'baseUrl': params?\['baseUrl'\] ?? baseUrl,  
      'path': params?\['path'\] ?? path,  
      'method': params?\['method'\] ?? method,  
      'headers': params?\['headers'\] ?? headers,  
      'authJwt': params?\['authJwt'\] ?? authJwt,  
      'pathParams': params?\['pathParams'\] ?? pathParams,  
      'queryParams': params?\['queryParams'\] ?? queryParams,  
      'body': params?\['body'\] ?? body,  
      'showLoading': params?\['showLoading'\] ?? showLoading,  
      'dismissible': params?\['dismissible'\] ?? dismissible,  
      'prettyLog': params?\['prettyLog'\] ?? prettyLog,  
      'saveTo': params?\['saveTo'\] ?? saveTo,  
    };  
    debugPrint("Calling RestfulDataAction with params: $merged");  
    ActionManager.instance.executeAction(context, type, merged);  
  }  
}  
*The RestfulDataAction class implements ActBase for executing RESTful API calls defined via JSON DSL. It uses an HTTP client (CgDioClient) to perform the actual network request. Key features:*  
*\- **Parameter merging and validation:** If a DSL specification is provided in params\['dataActionJSON'\], the action validates and merges parameters with defaults via validateValuesWithSpec. This ensures required parameters like baseUrl and path are present. If no spec is given, it manually merges any runtime parameters with the values provided in the constructor (which represent the DSL defaults). The result is a finalParams map containing the effective values for baseUrl, path, headers, etc.*  
*\- **HTTP request setup:** The action determines the HTTP method to use. If not explicitly provided, it defaults to GET or POST based on whether a body is present (this logic matches typical REST usage and the DSL default behavior). It constructs a combined URL from baseUrl and path (the path may include route parameters to be replaced using pathParams). Headers from both the DSL and runtime are combined and cast to Map\<String, String\>. If an authJwt token is provided, it automatically adds an Authorization: Bearer ... header (and an apikey header, if required by the API convention) for authentication.*  
*\- **Execution and error handling:** If showLoading is true, a loading dialog is displayed before the network call and dismissed afterwards. The CgDioClient (a wrapper around a Dio HTTP client in CreateGo) is used to make the request. It returns an Either\<String, dynamic\> where the left side is an error message (e.g., network error) and the right side is the response data (already decoded if JSON, according to CreateGo's implementation). The action returns a Left with an error message if the request fails. On success, it retrieves the response data.*  
*\- **Result saving:** Just like the SQL action, if a saveTo key is specified in the DSL or at runtime, the action will save the responseData (which could be a JSON-decoded map, list, or primitive type depending on the API) into the global state using SetModelAction.set. This allows other parts of the application (or subsequent actions in a flow) to access the API response easily by referencing the variable name.*  
*\- **Return value:** The result is wrapped in an ApiResponse object (for consistency within the CreateGo system) and returned as a Right value. The ApiResponse likely contains the HTTP status or other metadata internally, but here we mainly store the response payload.*

**open\_database\_action.dart**  
import 'package:fpdart/fpdart.dart';  
import 'package:sqlite3/sqlite3.dart';  
import 'package:creatego\_packages/creatego\_packages.dart';  // For ActBase, ApiResponse  
import 'database\_manager.dart';

class OpenDatabaseAction implements ActBase {  
  final String? dbKey;  
  final String? path;  
  final bool inMemory;

  OpenDatabaseAction({this.dbKey, this.path, this.inMemory \= false});

  @override  
  Future\<Either\<String, ApiResponse\>\> execute(  
      BuildContext? context, String methodName, Map\<String, dynamic\> params) async {  
    // Determine the database key to register.  
    final String? key \= (params\['dbKey'\] ?? dbKey) as String?;  
    if (key \== null || key.isEmpty) {  
      return left("OpenDatabaseAction Error: 'dbKey' is required to open a database.");  
    }  
    // Determine if we should open an in-memory database or file database.  
    bool useInMemory \= (params\['inMemory'\] ?? inMemory) \== true;  
    String? dbPath \= params\['path'\] ?? path;  
    if (\!useInMemory) {  
      if (dbPath \== null || dbPath.isEmpty) {  
        return left("OpenDatabaseAction Error: 'path' is required for opening a file database.");  
      }  
    }  
    // Prevent opening a duplicate connection for the same key.  
    if (DatabaseManager.getDatabase(key) \!= null) {  
      return left("OpenDatabaseAction Error: Database with key '$key' is already open.");  
    }  
    try {  
      // Open the database connection.  
      Database db;  
      if (useInMemory) {  
        db \= sqlite3.openInMemory();  
      } else {  
        db \= sqlite3.open(dbPath\!);  
      }  
      // Register the opened database in the manager.  
      DatabaseManager.registerDatabase(key, db);  
      // Optionally, we could set PRAGMAs or perform migrations here if needed.  
    } catch (e) {  
      return left("OpenDatabaseAction Error: Failed to open database. Details: ${e.toString()}");  
    }  
    // Return a success response (no specific data, just confirmation).  
    return right(ApiResponse(response: "Database '$key' opened successfully."));  
  }  
}  
*The OpenDatabaseAction is a callback action to open (or create) a SQLite database and register it under a given key. This allows subsequent SqliteDataAction calls to specify which database to use via that dbKey. Usage details:*  
*\- **Parameters:** It expects a dbKey (string) to identify the database connection. Additionally, a path can be provided to open a file-based database. If inMemory is true (either by constructor default or by a boolean flag in params), the action will open an in-memory database (which exists only in RAM for the app session). At runtime, you must supply either inMemory: true or a valid path (for file database) – otherwise it returns an error.*  
*\- **Behavior:** The action first checks that a database with the same key is not already open (to avoid unintentional duplicate connections). If an open DB with that key exists, it returns an error. If not, it proceeds to open a new database using the sqlite3 library. For in-memory databases, sqlite3.openInMemory() is used. For file databases, sqlite3.open(path) is used; this will create the database file if it does not exist, or open an existing file.*  
*\- **Registration:** After successfully opening the database, it calls DatabaseManager.registerDatabase(key, db) to store the Database instance in the central manager. This makes the connection available to SqliteDataAction calls via the same key. (At this point, you could also run any initialization SQL or PRAGMAs if needed – for example, setting foreign keys ON or running migrations – but that would be handled elsewhere in CreateGo.)*  
*\- **Result:** On success, the action returns a Right containing an ApiResponse with a confirmation message (e.g., "Database 'myDb' opened successfully."). On failure (e.g., invalid parameters or an sqlite3 exception while opening), it returns a Left with an error message. Typically, this action would be dispatched during app startup or when a certain feature module is initialized, to ensure the required database is ready for use.*

**close\_database\_action.dart**  
import 'package:fpdart/fpdart.dart';  
import 'package:creatego\_packages/creatego\_packages.dart';  // For ActBase, ApiResponse  
import 'database\_manager.dart';

class CloseDatabaseAction implements ActBase {  
  final String? dbKey;

  CloseDatabaseAction({this.dbKey});

  @override  
  Future\<Either\<String, ApiResponse\>\> execute(  
      BuildContext? context, String methodName, Map\<String, dynamic\> params) async {  
    final String? key \= (params\['dbKey'\] ?? dbKey) as String?;  
    if (key \== null || key.isEmpty) {  
      return left("CloseDatabaseAction Error: 'dbKey' is required to close a database.");  
    }  
    // Attempt to retrieve and remove the database from the manager.  
    final db \= DatabaseManager.unregisterDatabase(key);  
    if (db \== null) {  
      return left("CloseDatabaseAction Error: No open database found for key '$key'.");  
    }  
    try {  
      // Close the database connection.  
      db.dispose();  
    } catch (e) {  
      return left("CloseDatabaseAction Error: Failed to close database '$key'. Details: ${e.toString()}");  
    }  
    // Success: return confirmation.  
    return right(ApiResponse(response: "Database '$key' closed successfully."));  
  }  
}  
*The CloseDatabaseAction is a companion to OpenDatabaseAction. It closes an open SQLite database connection and unregisters it from the DatabaseManager. Key points:*  
*\- **Parameters:** It requires a dbKey identifying the database to close. This can be provided when constructing the action (if the action is tied to a specific database), or at runtime via params. If no key is provided, it returns an error because it doesn't know which database to act on.*  
*\- **Behavior:** The action uses DatabaseManager.unregisterDatabase(key) to remove the database instance from the central registry. This returns the Database object if one was stored under that key (or null if none). If no open database is found for the key, an error is returned (perhaps it was already closed or never opened). If a database is retrieved, the action calls db.dispose() to properly close the connection and release resources.*  
*\- **Result:** On success, it returns a Right with an ApiResponse containing a message confirming the database was closed. On failure (e.g., missing key or an exception during disposal), it returns a Left with an appropriate error message. After a database is closed, any further attempts to use that dbKey in SqliteDataAction will result in an error (until it's opened again), which helps prevent misuse of closed connections.*

*By combining OpenDatabaseAction and CloseDatabaseAction, the CreateGo platform can manage database lifecycles in a controlled manner. For example, the app could open its main database on startup (or when navigating to an offline-data-heavy module) and close it upon logout or when the data is no longer needed, thus freeing resources.*  
**Summary:** These implementations together form the CreateGo DataAction system for data management. **SqliteDataAction** and **RestfulDataAction** enable declarative data operations (local database queries and HTTP API calls, respectively) defined via JSON DSL. They handle runtime parameter validation, execution, and result handling in a functional style (using Either for error propagation). **OpenDatabaseAction** and **CloseDatabaseAction** manage database connections by key, allowing flexible use of multiple SQLite databases within the app. The **validateValuesWithSpec** utility ensures that input parameters conform to the DSL specification, improving reliability and reducing runtime errors. All components use fpdart's Either type to provide robust error handling without exceptions, aligning with CreateGo's functional programming approach in Dart.  
